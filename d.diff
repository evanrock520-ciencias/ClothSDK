diff --git a/core/include/engine/World.hpp b/core/include/engine/World.hpp
index e69de29..4de792c 100644
--- a/core/include/engine/World.hpp
+++ b/core/include/engine/World.hpp
@@ -0,0 +1,51 @@
+#pragma once
+
+#include <memory>
+#include <vector>
+#include <string>
+#include <Eigen/Dense>
+
+namespace ClothSDK {
+
+class Cloth;
+class Collider;
+class Force;
+
+class World {
+public:
+    World();
+
+    void addCloth(std::shared_ptr<Cloth> cloth);
+    void addCollider(std::shared_ptr<Collider> collider);
+    void addForce(std::shared_ptr<Force> force);
+    void clear();
+
+    void addPlaneCollider(const Eigen::Vector3d& origin, const Eigen::Vector3d& normal, double friction);
+    void addSphereCollider(const Eigen::Vector3d& center, double radius, double friction);
+
+    inline void setGravity(const Eigen::Vector3d& gravity) { m_gravity = gravity; }
+    inline void setWind(const Eigen::Vector3d& wind) { m_wind = wind; }
+    inline void setAirDensity(double density) { m_airDensity = density; }
+    inline void setThickness(double thickness) { m_thickness = thickness; }
+    
+    inline const Eigen::Vector3d& getGravity() const { return m_gravity; }
+    inline const Eigen::Vector3d& getWind() const { return m_wind; }
+    inline double getAirDensity() const { return m_airDensity; }
+    inline double getThickness() const { return m_thickness; }
+
+    inline const std::vector<std::shared_ptr<Cloth>>& getCloths() const { return m_cloths; }
+    inline const std::vector<std::shared_ptr<Collider>>& getColliders() const { return m_colliders; }
+    inline const std::vector<std::shared_ptr<Force>>& getForces() const { return m_forces; }
+
+private:
+    std::vector<std::shared_ptr<Cloth>> m_cloths;
+    std::vector<std::shared_ptr<Collider>> m_colliders;
+    std::vector<std::shared_ptr<Force>> m_forces;
+
+    Eigen::Vector3d m_gravity;
+    Eigen::Vector3d m_wind;
+    double m_airDensity;
+    double m_thickness;
+};
+
+} 
\ No newline at end of file
diff --git a/core/include/physics/Solver.hpp b/core/include/physics/Solver.hpp
index 3822e62..610eeb4 100644
--- a/core/include/physics/Solver.hpp
+++ b/core/include/physics/Solver.hpp
@@ -1,26 +1,9 @@
-/*
- * Copyright 2026 Evan M.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 #pragma once
 
 #include "Particle.hpp"  
 #include "Constraint.hpp"
-#include "Collider.hpp"
 #include "SpatialHash.hpp"
-#include "physics/Force.hpp"
+#include "engine/World.hpp" 
 #include <unordered_set>
 #include <vector>
 #include <memory>
@@ -34,66 +17,43 @@ public:
 
     int addParticle(const Particle& p);
     void clear();
-    void clearForces();
-
     const std::vector<Particle>& getParticles() const;
+    void setParticleInverseMass(int id, double invMass);
+    void addMassToParticle(int id, double mass);
 
-    void setGravity(const Eigen::Vector3d& gravity);
     void setSubsteps(int count);
     void setIterations(int count); 
-    void setParticleInverseMass(int id, double invMass);
-    void setWind(const Eigen::Vector3d& wind) {m_wind = wind; }
-    void setAirDensity(double density) {m_airDensity = density; }
-    void setThickness(double thickness) { m_thickness = thickness; }
     void setCollisionCompliance(double c) { m_collisionCompliance = c; }
+    
+    inline int getSubsteps() const { return m_substeps; }
+    inline int getIterations() const { return m_iterations; }
+    inline double getCollisionCompliance() const { return m_collisionCompliance; }
+    inline int getParticleCount() const { return static_cast<int>(m_particles.size()); }
 
     void addDistanceConstraint(int idA, int idB, double compliance);
     void addBendingConstraint(int a, int b, int c, int d, double restAngle, double compliance);
     void addPin(int id, const Eigen::Vector3d& pos, double compliance = 0.0);
-    void addMassToParticle(int id, double mass);
-    void addPlaneCollider(const Eigen::Vector3d& origin, const Eigen::Vector3d& normal, double friction);
-    void addSphereCollider(const Eigen::Vector3d& center, double radius, double friction);
-    void addAeroFace(int idA, int idB, int idC);
-    void addForce(std::unique_ptr<Force> force);
 
-    void update(double deltaTime);
-
-    inline int getSubsteps() const { return m_substeps; }
-    inline int getIterations() const { return m_iterations; }
-    inline const Eigen::Vector3d& getGravity() const { return m_gravity; }
-    inline double getAirDensity() const { return m_airDensity; }
-    inline const Eigen::Vector3d& getWind() const { return m_wind; }
-    inline double getThickness() const { return m_thickness; }
-    inline double getCollisionCompliance() const { return m_collisionCompliance; }
+    void update(World& world, double deltaTime);
 
 private:
-    void step(double dt);
-    void applyForces(double dt);
+    void step(World& world, double dt);
+    void applyForces(World& world, double dt);
+    void solveSelfCollisions(double dt, double thickness); 
+
     void predictPositions(double dt);
     void solveConstraints(double dt); 
-    void applyAerodynamics(double dt);
-    void solveSelfCollisions(double dt);
     uint64_t getAdjacencyKey(int idA, int idB) const;
 
-    struct AeroFace {
-        int a, b, c;
-    };
-
     std::vector<Particle> m_particles; 
     std::vector<std::unique_ptr<Constraint>> m_constraints;
-    std::vector<std::unique_ptr<Collider>> m_colliders;
-    std::vector<int> m_neighborsBuffer;
-    std::vector<std::unique_ptr<Force>> m_forces;
     std::unordered_set<uint64_t> m_adjacencies;
+    
     SpatialHash m_spatialHash;
-    Eigen::Vector3d m_gravity;
+    std::vector<int> m_neighborsBuffer;
+
     int m_substeps;
     int m_iterations;
-    std::vector<AeroFace> m_aeroFaces;
-    Eigen::Vector3d m_wind;
-    double m_airDensity;
-    double m_time; 
-    double m_thickness;
     double m_collisionCompliance;
 };
 
diff --git a/core/src/engine/World.cpp b/core/src/engine/World.cpp
index e69de29..7d99145 100644
--- a/core/src/engine/World.cpp
+++ b/core/src/engine/World.cpp
@@ -0,0 +1,35 @@
+#include "engine/World.hpp"
+#include "physics/PlaneCollider.hpp"
+#include "physics/SphereCollider.hpp"
+
+namespace ClothSDK {
+
+World::World() : m_airDensity(0.1), m_gravity(0.0, -9.81, 0.0), m_thickness(0.02) {}
+
+void World::addCloth(std::shared_ptr<Cloth> cloth) {
+    m_cloths.push_back(cloth);
+}
+
+void World::addCollider(std::shared_ptr<Collider> collider) {
+    m_colliders.push_back(collider);
+}
+
+void World::addForce(std::shared_ptr<Force> force) {
+    m_forces.push_back(force);
+}
+
+void World::clear() {
+    m_cloths.clear();
+    m_colliders.clear();
+    m_forces.clear();
+}
+
+void World::addPlaneCollider(const Eigen::Vector3d& origin, const Eigen::Vector3d& normal, double friction) {
+    m_colliders.push_back(std::make_unique<PlaneCollider>(origin, normal, friction));
+}
+
+void World::addSphereCollider(const Eigen::Vector3d& center, double radius, double friction) {
+    m_colliders.push_back(std::make_unique<SphereCollider>(center, radius, friction));
+}
+
+}
\ No newline at end of file
diff --git a/core/src/physics/Solver.cpp b/core/src/physics/Solver.cpp
index fb2e1e2..c5c00f1 100644
--- a/core/src/physics/Solver.cpp
+++ b/core/src/physics/Solver.cpp
@@ -4,53 +4,54 @@
 #include <omp.h>
 
 #include "physics/Solver.hpp"
+#include "engine/World.hpp"
 #include "physics/DistanceConstraint.hpp"
 #include "physics/BendingConstraint.hpp"
+#include "physics/Force.hpp"
 #include "physics/PinConstraint.hpp"
-#include "physics/PlaneCollider.hpp"
-#include "physics/SphereCollider.hpp"
 #include <Eigen/Dense>
 #include <memory>
 
 namespace ClothSDK {
     Solver::Solver()
-    : m_gravity(0.0, -9.81, 0.0), m_substeps(15), m_iterations(2), m_wind(2.0, 0.0, 1.0),
-    m_airDensity(0.1), m_time(0.0), m_collisionCompliance(1e-9), m_thickness(0.08), m_spatialHash(10007, 0.08) {}
+    : m_substeps(15), m_iterations(2), m_collisionCompliance(1e-9), m_spatialHash(10007, 0.08) {}
 
-    void Solver::update(double deltaTime) {
-        m_spatialHash.setCellSize(m_thickness); 
+    void Solver::update(World& world, double deltaTime) {
+        if (m_particles.empty()) return;
+
+        m_spatialHash.setCellSize(world.getThickness()); 
         m_spatialHash.build(m_particles);
-        m_time += deltaTime;
-        double substepDt = deltaTime / m_substeps;
-        for (int i = 0; i < m_substeps; i++)
-            step(substepDt);
+
+        double substepDt = deltaTime / static_cast<double>(m_substeps);
+        
+        for (int i = 0; i < m_substeps; i++) {
+            step(world, substepDt);
+        }
     }
 
-    void Solver::step(double dt) {
-        applyForces(dt);
+    void Solver::step(World& world, double dt) {
+        applyForces(world, dt);
+
         predictPositions(dt);
 
-        for (auto& constraint : m_constraints) 
+        for (auto& constraint : m_constraints) {
             constraint->resetLambda();
+        }
 
         for (int i = 0; i < m_iterations; i++) {
-            for(auto& constraint : m_constraints)
+            for(auto& constraint : m_constraints) {
                 constraint->solve(m_particles, dt);
+            }
         }
 
-        for (auto& collider : m_colliders) {
-            collider->resolve(m_particles, dt, m_thickness);
+        const auto& colliders = world.getColliders();
+        for (auto& collider : colliders) {
+            collider->resolve(m_particles, dt, world.getThickness());
         }
 
-        solveSelfCollisions(dt);
+        solveSelfCollisions(dt, world.getThickness());
     }
 
-    void Solver::applyForces(double dt) {
-    for (auto& force : m_forces) {
-        force->apply(m_particles, dt);
-    }
-}
-
     void Solver::predictPositions(double dt) {
         #pragma omp parallel for
         for (auto& particle : m_particles) {
@@ -66,7 +67,6 @@ namespace ClothSDK {
     void Solver::clear() {
         m_particles.clear();
         m_constraints.clear();
-        m_colliders.clear();
         m_adjacencies.clear();
     }
 
@@ -94,14 +94,6 @@ namespace ClothSDK {
         m_constraints.push_back(std::make_unique<PinConstraint>(id, pos, compliance));
     }
 
-    void Solver::addPlaneCollider(const Eigen::Vector3d& origin, const Eigen::Vector3d& normal, double friction) {
-        m_colliders.push_back(std::make_unique<PlaneCollider>(origin, normal, friction));
-    }
-
-    void Solver::addSphereCollider(const Eigen::Vector3d& center, double radius, double friction) {
-        m_colliders.push_back(std::make_unique<SphereCollider>(center, radius, friction));
-    }
-
     void Solver::addMassToParticle(int id, double mass) {
         Particle& pA = m_particles[id];
         pA.addMass(mass);
@@ -112,59 +104,16 @@ namespace ClothSDK {
             constraint->solve(m_particles, dt);
     }
 
-    void Solver::applyAerodynamics(double dt) {
-        if (dt < 1e-6) return;
-
-        double gust = std::sin(m_time * 5.0) * 0.5 + 0.5;
-        Eigen::Vector3d currentWind = m_wind * (1.0 + gust);
-
-        #pragma omp parallel for
-        for (int i = 0; i < (int)m_aeroFaces.size(); i++) {
-            auto& face = m_aeroFaces[i];
-            
-            Particle& pA = m_particles[face.a];
-            Particle& pB = m_particles[face.b];
-            Particle& pC = m_particles[face.c];
-
-            Eigen::Vector3d vFace = (pA.getVelocity(dt) + pB.getVelocity(dt) + pC.getVelocity(dt)) / 3.0;
-            Eigen::Vector3d vRel = vFace - currentWind;
-            double vMag = vRel.norm();
-            
-            if (vMag < 1e-4) continue;
-
-            Eigen::Vector3d edge1 = pB.getPosition() - pA.getPosition();
-            Eigen::Vector3d edge2 = pC.getPosition() - pA.getPosition();
-            Eigen::Vector3d n = edge1.cross(edge2);
-            double area = 0.5 * n.norm();
-            
-            if (area < 1e-6) continue;
-            
-            Eigen::Vector3d normal = n.normalized();
-
-            double pressure = vRel.dot(normal) / vMag;
-            Eigen::Vector3d force = -0.5 * m_airDensity * (vMag * vMag) * area * pressure * normal;
-            Eigen::Vector3d forcePerVtx = force / 3.0;
-
-            #pragma omp critical
-            {
-                pA.addForce(forcePerVtx);
-                pB.addForce(forcePerVtx);
-                pC.addForce(forcePerVtx);
-            }
-        }
-    }
-
-
-    void Solver::solveSelfCollisions(double dt) {
+    void Solver::solveSelfCollisions(double dt, double thickness) {
         double alphaHat = m_collisionCompliance / (dt * dt);
-        double thicknessSq = m_thickness * m_thickness;
+        double thicknessSq = thickness * thickness;
 
         for (int i = 0; i < (int)m_particles.size(); ++i) {
             Particle& pA = m_particles[i];
             double wA = pA.getInverseMass();
             if (wA == 0.0) continue;
 
-            m_spatialHash.query(m_particles, pA.getPosition(), m_thickness, m_neighborsBuffer);
+            m_spatialHash.query(m_particles, pA.getPosition(), thickness, m_neighborsBuffer);
 
             for (int j : m_neighborsBuffer) {
                 if (i >= j) continue; 
@@ -184,7 +133,7 @@ namespace ClothSDK {
                     double dist = std::sqrt(distSq);
                     Eigen::Vector3d normal = dir / dist;
 
-                    double C = dist - m_thickness;
+                    double C = dist - thickness;
                     
                     double deltaLambda = -C / (wSum + alphaHat);
                     Eigen::Vector3d corr = normal * deltaLambda;
@@ -196,6 +145,13 @@ namespace ClothSDK {
         }
     }
 
+    void Solver::applyForces(World& world, double dt) {
+        const auto& forces = world.getForces();
+        for (auto& force : forces) {
+            force->apply(m_particles, dt);
+        }
+    }
+
     uint64_t Solver::getAdjacencyKey(int idA, int idB) const{
         uint64_t low = static_cast<uint32_t>(std::min(idA, idB));
         uint64_t high = static_cast<uint32_t>(std::max(idA, idB));
@@ -211,24 +167,7 @@ namespace ClothSDK {
         m_substeps = count;
     }
 
-    void Solver::setGravity(const Eigen::Vector3d& gravity) {
-        m_gravity = gravity;
-    }
-
     void Solver::setParticleInverseMass(int id, double invMass) {
         m_particles[id].setInverseMass(invMass);
     }
-
-    void Solver::addAeroFace(int idA, int idB, int idC) {
-        m_aeroFaces.push_back({idA, idB, idC});
-    }
-
-    void Solver::addForce(std::unique_ptr<Force> force) {
-        m_forces.push_back(std::move(force));
-    }
-
-    void Solver::clearForces() {
-        m_forces.clear();
-    }
-
 }
diff --git a/d.diff b/d.diff
index bff3bcc..2f8b235 100644
--- a/d.diff
+++ b/d.diff
@@ -1,239 +0,0 @@
-diff --git a/CMakeLists.txt b/CMakeLists.txt
-index 9bbdb57..c706ac9 100644
---- a/CMakeLists.txt
-+++ b/CMakeLists.txt
-@@ -105,5 +105,4 @@ add_custom_target(cloth_sdk_stubs ALL
-     DEPENDS ${STUB_OUTPUT}
- )
- 
--enable_testing()
--add_subdirectory(tests)
-\ No newline at end of file
-+enable_testing()
-\ No newline at end of file
-diff --git a/core/include/engine/Cloth.hpp b/core/include/engine/Cloth.hpp
-index b19fea1..a3bc333 100644
---- a/core/include/engine/Cloth.hpp
-+++ b/core/include/engine/Cloth.hpp
-@@ -1,6 +1,7 @@
- #pragma once
- 
- #include "math/Types.hpp"
-+#include "physics/AerodynamicForce.hpp"
- #include <memory>
- #include <string>
- #include <vector>
-@@ -20,6 +21,8 @@ public:
-     inline const std::vector<int>& getParticleIndices() const { return m_particleIndices; }
-     inline const std::vector<Triangle>& getTriangles() const { return m_triangles; }
-     inline const std::vector<unsigned int>& getVisualEdges() const { return m_visualEdges; }
-+    inline void addAeroFace(int a, int b, int c) { m_faces.push_back({a, b, c}); }
-+    inline const std::vector<AeroFace>& getAeroFaces() const { return m_faces; }
-     inline int getParticleID(int r, int c) const { 
-         int localIndex = r * m_gridCols + c;
-         return m_particleIndices[localIndex];
-@@ -37,6 +40,7 @@ private:
-     std::vector<int> m_particleIndices;
-     std::vector<Triangle> m_triangles;
-     std::vector<unsigned int> m_visualEdges;
-+    std::vector<AeroFace> m_faces;
-     int m_gridRows;
-     int m_gridCols;
- };
-diff --git a/core/include/physics/Solver.hpp b/core/include/physics/Solver.hpp
-index 60fe49e..3822e62 100644
---- a/core/include/physics/Solver.hpp
-+++ b/core/include/physics/Solver.hpp
-@@ -20,6 +20,7 @@
- #include "Constraint.hpp"
- #include "Collider.hpp"
- #include "SpatialHash.hpp"
-+#include "physics/Force.hpp"
- #include <unordered_set>
- #include <vector>
- #include <memory>
-@@ -33,6 +34,7 @@ public:
- 
-     int addParticle(const Particle& p);
-     void clear();
-+    void clearForces();
- 
-     const std::vector<Particle>& getParticles() const;
- 
-@@ -52,16 +54,17 @@ public:
-     void addPlaneCollider(const Eigen::Vector3d& origin, const Eigen::Vector3d& normal, double friction);
-     void addSphereCollider(const Eigen::Vector3d& center, double radius, double friction);
-     void addAeroFace(int idA, int idB, int idC);
-+    void addForce(std::unique_ptr<Force> force);
- 
-     void update(double deltaTime);
- 
--    int getSubsteps() const { return m_substeps; }
--    int getIterations() const { return m_iterations; }
--    const Eigen::Vector3d& getGravity() const { return m_gravity; }
--    double getAirDensity() const { return m_airDensity; }
--    const Eigen::Vector3d& getWind() const { return m_wind; }
--    double getThickness() const { return m_thickness; }
--    double getCollisionCompliance() const { return m_collisionCompliance; }
-+    inline int getSubsteps() const { return m_substeps; }
-+    inline int getIterations() const { return m_iterations; }
-+    inline const Eigen::Vector3d& getGravity() const { return m_gravity; }
-+    inline double getAirDensity() const { return m_airDensity; }
-+    inline const Eigen::Vector3d& getWind() const { return m_wind; }
-+    inline double getThickness() const { return m_thickness; }
-+    inline double getCollisionCompliance() const { return m_collisionCompliance; }
- 
- private:
-     void step(double dt);
-@@ -80,6 +83,7 @@ private:
-     std::vector<std::unique_ptr<Constraint>> m_constraints;
-     std::vector<std::unique_ptr<Collider>> m_colliders;
-     std::vector<int> m_neighborsBuffer;
-+    std::vector<std::unique_ptr<Force>> m_forces;
-     std::unordered_set<uint64_t> m_adjacencies;
-     SpatialHash m_spatialHash;
-     Eigen::Vector3d m_gravity;
-diff --git a/core/src/engine/ClothMesh.cpp b/core/src/engine/ClothMesh.cpp
-index 1b910fc..56940e9 100644
---- a/core/src/engine/ClothMesh.cpp
-+++ b/core/src/engine/ClothMesh.cpp
-@@ -183,7 +183,7 @@ void ClothMesh::computePhysicalAttributes(Cloth& cloth, Solver& solver) const {
-         solver.addMassToParticle(triangle.b, massPerVertex);
-         solver.addMassToParticle(triangle.c, massPerVertex);
-         
--        solver.addAeroFace(triangle.a, triangle.b, triangle.c);
-+        cloth.addAeroFace(triangle.a, triangle.b, triangle.c);
-     }
- }
- 
-diff --git a/core/src/physics/Solver.cpp b/core/src/physics/Solver.cpp
-index 50e7554..fb2e1e2 100644
---- a/core/src/physics/Solver.cpp
-+++ b/core/src/physics/Solver.cpp
-@@ -42,19 +42,14 @@ namespace ClothSDK {
-             collider->resolve(m_particles, dt, m_thickness);
-         }
- 
--        solveSelfCollisions(m_thickness);
-+        solveSelfCollisions(dt);
-     }
- 
-     void Solver::applyForces(double dt) {
--        #pragma omp parallel for
--        for(auto& particle : m_particles) {
--            if(particle.getInverseMass() <= 0.0)
--                continue;
--            particle.addForce(m_gravity);
--        }
--        applyAerodynamics(dt);
--        
-+    for (auto& force : m_forces) {
-+        force->apply(m_particles, dt);
-     }
-+}
- 
-     void Solver::predictPositions(double dt) {
-         #pragma omp parallel for
-@@ -227,4 +222,13 @@ namespace ClothSDK {
-     void Solver::addAeroFace(int idA, int idB, int idC) {
-         m_aeroFaces.push_back({idA, idB, idC});
-     }
-+
-+    void Solver::addForce(std::unique_ptr<Force> force) {
-+        m_forces.push_back(std::move(force));
-+    }
-+
-+    void Solver::clearForces() {
-+        m_forces.clear();
-+    }
-+
- }
-diff --git a/data/animations/falling.abc b/data/animations/falling.abc
-index 732de79..799ff46 100644
-Binary files a/data/animations/falling.abc and b/data/animations/falling.abc differ
-diff --git a/examples/simulation.py b/examples/simulation.py
-index cd14df6..809f83c 100644
---- a/examples/simulation.py
-+++ b/examples/simulation.py
-@@ -46,7 +46,7 @@ def falling():
-         sdk.Logger.error("Failed to create Alembic file!")
-         return
- 
--    frames = 100
-+    frames = 600
-     dt = 0.016
- 
-     sdk.Logger.info(f"Simulating {frames} frames to {output_path}...")
-diff --git a/python/src/bindings.cpp b/python/src/bindings.cpp
-index 084278e..2134abf 100644
---- a/python/src/bindings.cpp
-+++ b/python/src/bindings.cpp
-@@ -14,6 +14,9 @@
- #include "physics/Collider.hpp"
- #include "physics/PlaneCollider.hpp"
- #include "physics/SphereCollider.hpp"
-+#include "physics/Force.hpp"
-+#include "physics/AerodynamicForce.hpp"
-+#include "physics/GravityForce.hpp"
- #include "physics/Solver.hpp"
- #include "engine/ClothMesh.hpp"
- #include "io/OBJLoader.hpp"
-@@ -44,6 +47,21 @@ PYBIND11_MODULE(cloth_sdk, m) {
-         .def_readwrite("shear_compliance", &ClothMaterial::shearCompliance)
-         .def_readwrite("bending_compliance", &ClothMaterial::bendingCompliance);
- 
-+    py::class_<ClothSDK::AeroFace>(m, "AeroFace")
-+        .def(py::init<int, int, int>(), py::arg("a"), py::arg("b"), py::arg("c"))
-+        .def_readwrite("a", &AeroFace::a)
-+        .def_readwrite("b", &AeroFace::b)
-+        .def_readwrite("c", &AeroFace::c);
-+
-+    py::class_<ClothSDK::Force, std::unique_ptr<ClothSDK::Force>>(m, "Force");
-+
-+    py::class_<ClothSDK::GravityForce, ClothSDK::Force, std::unique_ptr<ClothSDK::GravityForce>>(m, "GravityForce")
-+        .def(py::init<const Eigen::Vector3d&>(), py::arg("gravity"));
-+
-+    py::class_<ClothSDK::AerodynamicForce, ClothSDK::Force, std::unique_ptr<ClothSDK::AerodynamicForce>>(m, "AerodynamicForce")
-+        .def(py::init<const std::vector<AeroFace>&, const Eigen::Vector3d&, double>(), 
-+                py::arg("faces"), py::arg("wind"), py::arg("air_density"));
-+
-     py::class_<Particle>(m, "Particle")
-         .def(py::init<const Eigen::Vector3d&>(), py::arg("initial_pos"))
-         .def("get_position", &Particle::getPosition)
-@@ -84,9 +102,6 @@ PYBIND11_MODULE(cloth_sdk, m) {
-         .def("clear", &Solver::clear)
-         .def("add_particle", &Solver::addParticle)
-         .def("get_particles", &Solver::getParticles, py::return_value_policy::reference_internal)
--        .def("get_wind", &Solver::getWind)
--        .def("set_gravity", &Solver::setGravity)
--        .def("get_gravity", &Solver::getGravity)
-         .def("set_substeps", &Solver::setSubsteps)
-         .def("set_iterations", &Solver::setIterations)
-         .def("add_distance_constraint", &Solver::addDistanceConstraint)
-@@ -94,11 +109,15 @@ PYBIND11_MODULE(cloth_sdk, m) {
-         .def("add_pin", &Solver::addPin)
-         .def("add_plane_collider", &Solver::addPlaneCollider)
-         .def("add_sphere_collider", &Solver::addSphereCollider)
--        .def("set_wind", &Solver::setWind)
--        .def("set_air_density", &Solver::setAirDensity)
-         .def("set_thickness", &Solver::setThickness)
-         .def("set_collision_compliance", &Solver::setCollisionCompliance)
--        .def("set_particle_inverse_mass", &Solver::setParticleInverseMass);
-+        .def("set_particle_inverse_mass", &Solver::setParticleInverseMass)
-+        .def("add_force", [](Solver &s, py::object force_obj) {
-+            auto force_ptr = force_obj.cast<Force*>(); 
-+            s.addForce(std::unique_ptr<Force>(force_obj.cast<Force*>()));
-+            force_obj.inc_ref(); 
-+        }, py::keep_alive<1, 2>())
-+        .def("clear_forces", &Solver::clearForces);;
- 
-     py::class_<ClothMesh, std::shared_ptr<ClothSDK::ClothMesh>>(m, "ClothMesh")
-         .def(py::init<>())
-@@ -115,6 +134,7 @@ PYBIND11_MODULE(cloth_sdk, m) {
-         .def("get_material", &Cloth::getMaterial)
-         .def("set_material", &Cloth::setMaterial)
-         .def("get_particle_indices", &Cloth::getParticleIndices)
-+        .def("get_aerofaces", &Cloth::getAeroFaces)
-         .def("get_triangles", [](const Cloth& cloth) {
-             std::vector<int> flat;
-             for (const auto& t : cloth.getTriangles()) {
